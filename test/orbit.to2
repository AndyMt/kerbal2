use { Vessel, AutopilotMode, VesselSituation, DeltaVSituation  } from ksp::vessel
use { Body, Orbit } from ksp::orbit
use { vec2, vec3, Vec3 } from ksp::math
use { CONSOLE } from ksp::console
use { sleep, current_time } from ksp::game

use { acos_deg, max, clamp, sqrt, PI, min } from core::math
use { format } from core::str

use { Mission } from glib::mission
use { warning, panic } from glib::display

//
// Maneuver Node and helper functions
//

struct Node(t : float, dv : Vec3) {
    time: float = t
    delta_v: Vec3 = dv
}

impl Node {

    // Is this a good/bad Node
    sync fn isError(self) -> bool = {
        if (self.time == -1) return true
        false
    }

    sync fn isValid(self) -> bool = {
        if (self.time == -1) return false
        true
    }

    sync fn to_string(self) -> string = {
        let t = glib::display::pretty_time(self.time-current_time())
        return format("In {0}  dV: {1:N1} m/s", (t,self.delta_v.magnitude))    
    }

    // Estimate burn time for the node. Assume all in a single (current) stage
    sync fn estBurnTime(self, vessel: Vessel) -> float = {
        const maybe_stage_info = vessel.delta_v.stage(vessel.staging.current)
        if(!maybe_stage_info.defined) return -1

        const stage_info = maybe_stage_info.value
        const stage_deltav = stage_info.get_deltav(DeltaVSituation.Vaccum)
        if (stage_deltav < self.delta_v.magnitude) {
            warning(format("Insufficient dv: {0:N1} m/s need {1:N1} m/s", (stage_deltav, self.delta_v.magnitude)))
            return -1    
        }

        const stage_thrust = stage_info.get_thrust(DeltaVSituation.Vaccum)

        return min(self.delta_v.magnitude/(stage_thrust/vessel.mass), stage_info.burn_time)
    }

    fn addManeuver(self, vessel: Vessel) -> Unit = {
        let burn_time = self.estBurnTime(vessel)
        if (burn_time > 0) {
            vessel.maneuver.add_burn_vector(self.time - burn_time/2, self.delta_v)
        }
    }

}

// Returns an invalid node
pub sync fn ErrorNode() -> Node = {
    return Node(-1, vec3(1,2,3))
}

//
// Functions for simple orbit adjustments
//

// Time needed for Hohmann transfer from alt1->alt2

pub sync fn t_hohmann(orbit : Orbit, alt1: float, alt2: float) -> float = {
    let body_radius = 1.0 // XXX
    let body_mu = orbit.reference_body.grav_parameter
    return PI * sqrt( (alt1+alt2+2*body_radius)^3/(8*body_mu) )
}

// Velocity at a specific altitude for current orbit.

pub sync fn vv_alt(orbit: Orbit, r: float) -> float = { 
  let body = orbit.reference_body
  return sqrt(body.grav_parameter*(2/(r+body.radius)-1/orbit.semi_major_axis))
}

// Velocity at a specific altitude for an arbitrary orbit

pub sync fn vv_axis(orbit: Orbit, r: float, axis: float) -> float = {
  let body = orbit.reference_body
  return sqrt(body.grav_parameter*(2/(r+body.radius)-1/axis))
}

// Velocity for a circular orbit at a given altitude AGL

pub sync fn vv_circular(orbit: Orbit, r: float) -> float = {
  return vv_axis(orbit, r, r+orbit.reference_body.radius)
}

// Chage the Periapsis at the next Apoapsis

pub sync fn change_pe_at_ap(vessel: Vessel, new_pe: float) -> Node = {
    let t_ap = vessel.orbit.next_apoapsis_time()
    let ap = vessel.orbit.apoapsis
    if (!t_ap.defined || !ap.defined) {
        panic("Apoapsis undefined in change_pe_at_ap.")
        return ErrorNode()
    }
    let v_ap = vv_alt(vessel.orbit,ap.value)
    let v_new = vv_axis(vessel.orbit,ap.value,(ap.value+2*vessel.orbit.reference_body.radius+new_pe)/2)
    let dv = (v_new-v_ap)*vessel.orbit.prograde(t_ap.value)
    return Node(t_ap.value,dv)
}

pub sync fn change_ap_at_pe(vessel: Vessel, pe: float) -> Node = {
    return ErrorNode() 
}

pub sync fn circularize_at_ap(vessel: Vessel) -> Node = {
    if (!vessel.orbit.apoapsis.defined) {
        panic("Apoapsis undefined in circualize_at_ap.")
        return ErrorNode()
    }
    return change_pe_at_ap(vessel, vessel.orbit.apoapsis.value)    
}

pub sync fn circularize_at_pe(vessel: Vessel) -> Node = {
    return ErrorNode()    
}

pub fn main_flight(vessel: Vessel) -> Unit = {

    // Standard Setup
    let mission = Mission("Test Flight v1",vessel)
    let con = mission.start()

    // If we are landed or pre-launch, launch
    if (vessel.situation == VesselSituation.Landed || vessel.situation == VesselSituation.PreLaunch) {
        con.log("Launch.")
        vessel.set_throttle(1)
        mission.stage()
        vessel.autopilot.mode = AutopilotMode.Autopilot
    }

    let turn_min = 0.007
    let turn_max = 0.6
    let target_apoapsis = 80000
    let heading = 90

    // calculate gravity turn altitures
    let ath_depth = vessel.main_body.atmosphere_depth
    let turn_min_alt = ath_depth * turn_min
    let turn_max_alt = ath_depth * turn_max

    con.log(format("Target Apoapsis {0:N}, heading {1:N} deg.", (target_apoapsis, heading)))
    con.h4 = format("Gravity turn starting at {0:N}m", turn_min_alt)

    // Phase one: burn until trajectory is close to apoapsis
    while(vessel.orbit.apoapsis.value < target_apoapsis) {

        // Check if high enough for gravity turn
        if (vessel.altitude_sealevel > turn_min_alt) {
            let pitch = acos_deg(clamp((vessel.altitude_sealevel - turn_min_alt) / (turn_max_alt-turn_min_alt), 0, 1))
            vessel.autopilot.target_orientation = vessel.heading_direction(heading, pitch, 0).vector
            con.h4 = format("Launch: {0:P1}  pitch: {1:N1} deg", (vessel.altitude_sealevel/target_apoapsis, pitch))
        }

        // Check if we need to stage
        if( mission.flameout() ) {
            con.log("Flameout, advancing to new stage.")
            sleep(1)
            mission.stage()       
        }
        con.update1()
    }

    vessel.set_throttle(0)
    vessel.autopilot.mode = AutopilotMode.Prograde

    let t_apo = vessel.orbit.next_apoapsis_time().value
    con.log(format("Apoapsis {0:N} in {1:N} seconds.", (vessel.orbit.apoapsis.value, t_apo-current_time())))

    let n = circularize_at_ap(vessel)
    con.log("Node: "+n.to_string())
    con.log("Burn time: "+n.estBurnTime(vessel).to_string()+" s")

    n.addManeuver(vessel)
    mission.burnNextNode()   

    mission.end()
}